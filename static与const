_1)面试官: static和const分别怎么用？

回答:
static的用法:
1. 对于变量:
   - 局部变量: 在局部变量前加static使其成为局部静态变量。存储在data段，只能初始化一次，作用域仍为局部，但生命周期延长至程序结束。
   - 全局变量: 在全局变量前加static使其成为全局静态变量。存储在静态存储区，自动初始化为0，作用域仅限于定义它的文件内。

2. 对于函数:
   - 修饰普通函数，限制函数作用域仅在定义它的文件内，防止多人开发时的命名冲突。

3. 对于类:
   - 成员变量: 用static修饰使该成员成为类的全局变量，被所有对象共享。必须在类外初始化（const static成员可在类内初始化）。
   - 成员函数: 用static修饰使该函数属于类而非对象，所有对象共享，不含this指针，可独立访问（无需创建对象实例）。

const的用法:
1. 修饰变量: 限定变量为不可修改。
2. 修饰指针:
   a.指向常量的指针（指针指向的内容是常量）
      写法：const int *p 或 int const *p
      含义：指针可以指向不同的地址，但不能通过这个指针来修改它所指向的值。
      理解：const修饰的是 *p（指针解引用的内容），所以内容不可变。

   b.常量指针（指针本身是常量）
      写法：int *const p
      含义：指针一旦初始化后就不能再指向其他地址，但可以通过这个指针修改它所指向的值。
      理解：const修饰的是 p（指针变量本身），所以指针的指向不可变。
3. 和函数结合:
   - 修饰返回值：保护返回的数据不被修改
   - 修饰形参：保护传入的参数不被函数内部修改  
   - 修饰成员函数：承诺不修改对象状态，使得 const 对象也能调用该函数
   a. const int& fun(int& a);   // const 修饰返回值
      - 含义：函数返回一个指向常整数的引用
      - 作用：调用者不能通过返回的引用来修改所指向的值
      - 示例：const int& result = fun(a); 之后不能做 result = 10; 这样的修改

   b. int& fun(const int& a);   // const 修饰形参
      - 含义：参数 a 是一个指向常整数的引用
      - 作用：函数内部不能通过引用 a 来修改外部传入的变量
      - 好处：既避免了拷贝开销，又保证了原始数据不被意外修改

   c. int& fun(int& a) const;   // const 修饰成员函数
      - 含义：这是一个 const 成员函数
      - 作用：该函数不能修改类的任何非静态成员变量（mutable 修饰的变量除外）
      - 特点：只能调用其他 const 成员函数
      - 重要性：const 对象只能调用 const 成员函数，这是 C++ 的重要特性
4. 和类结合:
   a.const修饰成员变量（常成员变量）：
      - 特性：在对象的整个生命周期内，该成员变量的值不可改变。
      - 初始化：必须在构造函数的初始化列表中初始化，不能在构造函数体内赋值。
      - 灵活性：虽然每个对象的该成员值不可变，但不同对象可以有不同的初始值。

   b.const修饰成员函数（常成员函数）：
      - 特性：该函数不能修改类的任何非静态成员变量（mutable修饰的变量除外）。
      - 语法：在函数声明的参数列表后加上const关键字。
      - 限制：常成员函数只能调用其他常成员函数。
      - 重要性：保证函数不会改变对象的状态。

   c.const对象（常对象）：
      - 特性：对象本身的所有数据成员在生命周期内都不可修改。
      - 限制：常对象只能调用常成员函数，不能调用非常成员函数。
      - 用途：保护对象数据不被意外修改，常用于函数参数传递或返回值。


_2)面试官: 类里面static和const可以同时修饰成员函数吗？

回答: 不可以。原因如下:
- static成员函数属于类而非对象，没有this指针。
- const成员函数需要隐式的const this*参数来确保不修改对象状态。
- 两者语义矛盾：static表示函数仅作用于类的静态变量，与实例无关；const表示函数不修改实例状态，与静态变量无关。
- 因此，C++中不允许同时用static和const修饰成员函数。


_3)面试官: static初始化时机和线程安全问题？

回答:
面试官您好，关于static变量的初始化时机和线程安全问题，我的理解如下：
1) 初始化时机
   a.C语言：
   所有静态变量（包括全局变量和函数内的静态局部变量）在程序main函数执行之前完成内存分配和初始化。
   其初始值若在编译期已知（如static int i = 5;），则直接写入程序的数据段，由加载器在程序启动时完成初始化。
   b.C++语言：
   静态初始化/编译期初始化：在程序加载时完成，包括：
      - 零初始化：未显式初始化的静态变量被设为0值。
      - 常量初始化：编译期值已知的变量（如constexpr、字面量初始化）。
   动态初始化/运行时初始化：需要执行代码的初始化（如调用构造函数、函数返回值初始化）。
      - 非局部静态变量（全局、命名空间、类静态成员变量）：在main函数开始之前进行，但不同编译单元间的初始化顺序不确定。
      - 局部静态变量：在控制流首次经过其声明语句时进行（惰性初始化）。

2)线程安全
   a.C语言：
   初始化安全：所有初始化在main之前完成，处于单线程环境，因此是线程安全的。
   访问安全：初始化完成后，多线程下的读写操作需要程序员自行加锁保证安全。
   b.C++语言：
   非局部静态变量：
      - 初始化安全：在main之前初始化，处于单线程环境，因此是安全的。
      - 访问安全：初始化后的并发读写需程序员负责同步。
   局部静态变量 (C++11起)：
      - 初始化安全：是线程安全的。C++11标准强制要求编译器必须保证其初始化操作只执行一次。编译器会使用类似双重检查锁定的机制，确保即使多线程同时触发初始化，也只有一个线程执行构造，其他线程会阻塞等待完成。
      - 访问安全：初始化完成后，其作为一个共享变量，多线程下的读写操作仍需程序员自己保证线程安全。

总结：C++11保证了局部静态变量初始化过程的线程安全，这是实现线程安全单例模式的基础。但所有静态变量初始化后的使用过程，其线程安全都必须由开发者通过锁等同步机制来保障。

_4)面试官: C++中局部静态变量的问题？

回答:
1. 特点: 存储在静态存储区，自动初始化为0，作用域局部但生命周期到程序结束。
2. 构造和析构: 
   - 首次执行到定义处时构造，析构顺序与构造顺序相反。
   - 问题: 构造顺序取决于实际执行路径（可能不可预知），且分散的局部静态变量易忽略相互依赖关系，可能导致问题。
3. 建议: 尽量少使用静态变量，避免潜在问题。
4. 函数返回局部静态变量: 允许（如示例代码），但需注意其持久性可能带来意外状态保留。

示例代码片段:
int tmp() {
    static int b = 5;  // 局部静态变量
    return b;
}
// 可返回，且值在多次调用间保持

_5)面试官: const与指针的区别？

回答:
主要两种形式:
1. 指向常量的指针: 
   - 写法: const int *p 或 int const *p
   - 含义: 不能通过解引用(*p)修改所指内容，但指针本身可指向其他地址。
2. 常量指针:
   - 写法: int *const p
   - 含义: 指针本身地址不可变（初始化后不能指向其他地址），但可通过解引用(*p)修改所指内容。
注意: const int p 是常量本身（非指针），初始化后值不可变。
