1.面试官：你的网盘项目使用了json技术，为什么要使用，怎么使用的？

回答：首先二进制协议比较依赖编译环境，比如32位/64位结构体大小不一样，传数据容易乱，但是json是文本格式，不管什么环境，按键读就行，不会错。
其次就是传输复杂信息方便。比如分享下载时，要给客户端发文件id+名字+总大小，二进制就需要定义专门的结构体；而json直接写字段的赋值就可以，相加字段直接加键就可以，不需要改协议。
然后Redis缓存也能看懂。这个项目用Redis缓存分享码信息，二进制存进去没法直接看（得解码）；json存进去，用工具能直接看到文件路径是什么，什么时候过期，调试更方便。

项目中使用json技术主要是在分享文件相关功能用吧。因为大文件传输还是得用二进制，不然慢。、
首先分享下载方面呢，就是服务器发json，客户端解json。其实这过程就是json的序列化和反序列化，服务器把文件id、文件名字等数据转换成json字符串（序列化）发出去，客户端收到后再把json字符串转成自己能操作的变量（反序列化）。

这里的json分为三部分传输，head部分，body部分，tail部分，其中body部分中的文件本体虽然通过json传说书，但是本质上还是二进制数据，只不过通过base64编码嵌入json中。






2.面试官： Redis 缓存能看懂：项目用 Redis 存分享码信息，二进制存进去没法直接看（得解码）；JSON 存进去，用工具查能直接看到 “文件路径是啥、啥时候过期”，调试时不用猜。
这样不会更不安全吗？

回答：
这个担心很合理 ——JSON 的 “可读性” 确实意味着 “能直接看到内容”，但项目里通过 3 个关键设计，把这种 “可见性” 的安全风险降到了最低，不会真的导致安全问题：

首先，Redis 本身有访问权限控制：项目里的 Redis 不是公网可访问的，只有服务器能通过内网连接（比如绑定服务器本地 IP，设密码），外人根本连不上 Redis，就算 JSON 能看懂，也没机会看到 —— 相当于 “家里的账本是手写的（易看懂），但家门锁得很严，外人进不来”，基础安全有保障。

其次，分享码是 “短期随机 + 唯一” 的：JSON 里存的信息（文件路径、ID）是和 “4 位随机分享码” 绑定的，而分享码 24 小时就过期（Redis 自动删），就算有人碰巧拿到一个分享码、看到了 JSON 里的路径，过一天也失效了；而且 4 位分享码是随机的（数字 + 字母），想猜中有效码很难，相当于 “账本里的内容只对当天的临时钥匙有效，钥匙过期或不对，内容再懂也没用”。

最后，JSON 里只存 “非敏感的关联信息”：就算真被看到，JSON 里只有 “文件 ID、服务器内部路径、过期时间”，没有文件内容（文件内容要通过下载流程才能拿到，还得校验分享码），也没有用户密码、隐私数据；而且服务器内部路径（比如 “C:/data/123.pdf”）只是服务器本地地址，外人就算知道这个路径，也没法直接访问服务器的文件 —— 相当于 “账本里记的是‘仓库 123 号货架’，不是‘仓库大门钥匙’，知道货架号也拿不到东西”。

简单说：JSON 的 “易看懂” 主要是为了方便自己调试，而安全靠 “Redis 锁门 + 分享码限时 + 只存无关痛痒的信息” 来保障，两者不冲突。





3.面试官：你说大文件传输还靠二进制，不然慢，那你怎么定义或判断什么是大文件的，那你分享下载方面是怎么抉择二进制和json的

在项目中，“大文件” 的定义和传输方式的抉择，是结合数据体积、传输效率和业务场景定的，不是单纯看大小，核心是 “哪种方式更适合当前数据的特性”。
一、怎么定义 “大文件”？—— 两个判断维度
项目里没硬性规定 “超过 XX MB 就是大文件”，而是从两个角度灵活判断：

内容类型：如果是二进制文件（视频、图片、压缩包等），不管大小，默认按 “大文件” 逻辑处理 —— 因为这类文件本身是字节流，转成 JSON 的 Base64 编码会膨胀 30% 以上（比如 100MB 的文件会变成 130MB），纯浪费带宽。
实际体积：文本类文件（如 txt、csv）如果超过 1MB，也按 “大文件” 算 —— 因为 1MB 的文本转 JSON 后，解析时会占用更多内存（JSON 库需要一次性加载解析），而二进制分块传输可以边传边写盘，内存压力小。
二、分享下载中，二进制和 JSON 的抉择原则：“元数据用 JSON，文件本体用二进制”
分享下载的流程里，数据分两类，对应不同传输方式，界限很清晰：

“描述性信息” 用 JSON
比如 “分享码对应的文件 ID、文件名、总大小、传输阶段（HEAD/TAIL）” 这些元数据，特点是 “体积小、结构化强、需要跨模块解析”。
举例：分享提取时，服务器先给客户端发 “这是个 200MB 的视频，叫 xxx.mp4”（HEAD 消息），用 JSON 传最方便 —— 客户端能快速解析出 “要创建多大的本地文件”，而且这些信息加起来就几百字节，JSON 的额外开销可以忽略。
“文件本体数据” 用二进制
不管文件是 10MB 还是 1GB，只要是实际的文件内容（比如视频的帧数据、压缩包的字节流），一律用二进制分块传输 —— 因为：
二进制不用编码（Base64 会增加体积 + 耗时），100MB 的文件能省 30MB 带宽；
分块传输（4KB / 块）可以边传边写盘，客户端不用在内存里缓存整个文件，避免内存溢出（比如 2GB 的文件，JSON 根本扛不住）。
三、极端情况的处理：小文件也优先用二进制
就算是 100KB 的小文件，分享下载时依然是 “JSON 传元数据 + 二进制传内容”。
不是不能用 JSON（100KB 转 Base64 也就 130KB），而是为了逻辑统一—— 项目里上传、下载、分享下载复用了同一套分块传输逻辑（4KB / 块、断点续传），如果小文件单独用 JSON，就得写两套代码，维护成本高。

简单说：JSON 负责 “说清楚要传什么”，二进制负责 “高效传东西”，分工明确，既兼顾了灵活性，又保证了大文件传输的性能。





4.面试官：downloadbyjson处理 “通过分享码下载他人文件”，无论什么文件经过分享都用json传输下载吗
不是 “无论什么文件都用 JSON 传输”，而是 **“分享场景下必须通过 JSON 协议完成传输流程”—— 无论文件大小 / 类型，只要是 “通过分享码下载他人文件”，就一定走downloadbyjson的 JSON 传输逻辑，但这并不意味着 “整个文件用 JSON 格式存储”，而是“用 JSON 封装传输所需的结构化信息，文件本体依然是二进制数据（只是通过 Base64 编码嵌入 JSON）”**。

核心原因是分享场景的特殊性必须依赖 JSON 的结构化能力：
分享下载的前提是 “先验证分享码有效性”，且传输过程需要明确区分 “验证结果、文件元数据、分块数据、传输完成” 这几个阶段（比如 “先告诉客户端‘这个分享码有效，文件叫什么、多大’，再传数据，最后说‘传完了’”）。这些 “阶段信息” 和 “结构化元数据”（如文件 ID、总大小）必须用 JSON 的键值对来清晰表达，否则客户端无法判断 “现在该做什么”（是初始化文件？还是写入数据？）。

具体来说，即便是 GB 级的大文件，通过分享码下载时：

依然由downloadbyjson处理，用 JSON 传输三个阶段的信息：
HEAD 阶段（JSON）：传 “文件 ID、名称、总大小”（让客户端知道要创建多大的文件）；
BODY 阶段（JSON）：传 “Base64 编码的二进制块 + 块序号”（文件本体是二进制，只是为了嵌入 JSON 做了编码）；
TAIL 阶段（JSON）：传 “传输状态”（告诉客户端可以收尾了）。
不会因为文件大就改用纯二进制协议，因为分享场景必须依赖 JSON 的结构化能力来串联 “验证 - 传元数据 - 传数据 - 收尾” 的完整流程，否则客户端无法解析 “这堆二进制里哪部分是验证结果、哪部分是文件数据”。

简单说：分享下载的核心是 “先处理分享码相关的结构化信息，再传文件”，而 JSON 是承载这些结构化信息的最佳方式，因此无论文件本身是什么样，只要走分享流程，就一定用downloadbyjson的 JSON 传输逻辑 —— 文件本体还是二进制，只是 “搭了 JSON 的车” 来完成整个分享下载的流程。







5.面试官：那文件本质是二进制，只是嵌入json中，也就是json不负责下载吗

不能说 “JSON 不负责下载”，它更像是 “分享下载流程的‘组织者’”—— 虽然文件本体（二进制）是下载的核心内容，但没有 JSON，这部分二进制数据根本没法正确完成下载，两者是分工协作、缺一不可的关系。

具体来说：
二进制负责 “传输下载的核心内容（文件本身）”，但它只知道 “传什么”，不知道 “传给谁、怎么用、传到哪一步了”；而 JSON 负责 “解决这些‘怎么传’的关键问题”，让二进制数据能被正确处理，最终完成下载。

比如分享下载时的实际流程：

没有 JSON 的话，服务器就算把二进制文件块发给客户端，客户端也不知道 ——“这是哪个文件的块？”（需要 JSON 里的fileId）、“我该在本地建个多大的文件存？”（需要 JSON 里的totalSize）、“这个块该放在文件的第几个位置？”（需要 JSON 里的blockNum）；
反过来，只有 JSON 没有二进制的话，客户端只能拿到 “有个文件叫 XXX，大小 200MB” 的信息，却拿不到实际的文件内容，下载也等于没完成。

所以准确的理解是：

二进制：负责 “传输下载的‘实体内容’”（文件字节流），是下载的 “核心物料”；
JSON：负责 “传输下载的‘流程信息’”（文件元数据、块顺序、传输阶段），是下载的 “操作指南”；

两者结合才能完成分享下载 ——JSON 让二进制数据 “有方向、有规则地被处理”，二进制让 JSON 的 “操作指南” 有实际意义，少了谁都不行。
