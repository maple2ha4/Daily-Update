面试官：为什么左值默认不能被移动，需要显式使用std::move？

应聘者：
这是一个非常好的问题，它触及了C++移动语义的设计核心。左值本身是可以被移动的，但默认情况下不允许，需要程序员显式地用std::move来授权。

这种设计主要基于三个关键考虑：

1. 安全性：防止意外破坏
左值通常是有名字的变量，在当前作用域之后很可能还会被使用。

举例说明风险：
std::vector<int> data = get_important_data(); // data 是左值
process_data(data); // 如果这个函数"偷偷"移动了data

// ... 后续代码 ...
std::cout << data.size(); // 灾难！data可能已被掏空

C++采用保守策略：默认假设左值还需要被使用，只允许拷贝，这保证了代码的默认行为是安全的。

2. 明确程序员的意图
移动操作具有"破坏性"：
• 移动后源对象内容不确定（通常为空）
• 这种操作不应该悄悄发生

std::move的本质作用： 将左值转换成将亡值,表示这个左值后续不需再使用了,你可以用来执行移动拷贝了
• 对编译器：允许调用移动构造函数/赋值运算符
• 对程序员：明确表示不再使用该对象

示例对比：
// 意图模糊：会发生拷贝还是移动？
process_data(data);

// 意图明确：主动授权移动，知道data之后没用了
process_data(std::move(data));

std::move(data)执行后,std::move(data)为将亡值,而data仍然为左值,但接下来如果执行移动构造就不能再使用data

3. 与语言特性保持一致
C++的哲学：可能改变对象状态的操作需要显式表示
• 修改变量需要赋值运算符 =
• 修改指针需要重新赋值
• 修改const对象是非法的

移动操作会改变源对象状态，因此遵循同样的原则：修改需要显式进行。

完美类比：
• 左值：你的房子和财产（默认只能查看，不能拿走）
• std::move：你写的"东西不要了"的字条
• 移动语义：看到字条的人可以进来搬走电视

总结：
不是"左值不可移动"，而是"移动左值需要显式授权"。
这是一种保护机制，通过std::move让程序员明确表达放弃资源所有权的意图，既保证了安全性又明确了代码意图。
