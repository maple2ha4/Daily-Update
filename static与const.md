面试官: static和const分别怎么用？

回答:
static的用法:
1. 对于变量:
   - 局部变量: 在局部变量前加static使其成为局部静态变量。存储在data段，只能初始化一次，作用域仍为局部，但生命周期延长至程序结束。
   - 全局变量: 在全局变量前加static使其成为全局静态变量。存储在静态存储区，自动初始化为0，作用域仅限于定义它的文件内。

2. 对于函数:
   - 修饰普通函数，限制函数作用域仅在定义它的文件内，防止多人开发时的命名冲突。

3. 对于类:
   - 成员变量: 用static修饰使该成员成为类的全局变量，被所有对象共享。必须在类外初始化（const static成员可在类内初始化）。
   - 成员函数: 用static修饰使该函数属于类而非对象，所有对象共享，不含this指针，可独立访问（无需创建对象实例）。

const的用法:
1. 修饰变量: 限定变量为不可修改。
2. 修饰指针:
   - 指向常量的指针（const int *p 或 int const *p）: 不能通过解引用修改所指内容。
   - 常量指针（int *const p）: 指针本身地址不可变，但可通过解引用修改所指内容。
3. 和函数结合:
   - const int& fun(int& a);  //修饰返回值
   - int& fun(const int& a);  //修饰形参
   - int& fun(int& a) const;  //const成员函数，不能修改成员变量
4. 和类结合:
   - const修饰成员变量: 在对象生命周期内为常量，但不同对象可不同值。只能在初始化列表初始化。
   - const修饰成员函数: 防止函数修改成员变量值。
   - const对象: 常对象，只能调用常成员函数。

面试官: 类里面static和const可以同时修饰成员函数吗？

回答: 不可以。原因如下:
- static成员函数属于类而非对象，没有this指针。
- const成员函数需要隐式的const this*参数来确保不修改对象状态。
- 两者语义矛盾：static表示函数仅作用于类的静态变量，与实例无关；const表示函数不修改实例状态，与静态变量无关。
- 因此，C++中不允许同时用static和const修饰成员函数。

面试官: static初始化时机和线程安全问题？

回答:
1. 初始化时机:
   - C语言: 静态局部变量和全局变量在编译阶段分配内存并初始化，程序结束时回收。
   - C++: 引入类后，初始化更复杂。分为:
        * 编译初始化（静态初始化）: 全局变量、const变量（zero initialization和const initialization）存储在bss或data段，程序加载时完成。
        * 运行时初始化（动态初始化）: 需要函数调用或类构造的初始化（如局部静态类对象或变量），在首次用到时初始化。

2. 线程安全:
   - C语言: 非局部静态变量在main执行前初始化，线程安全。
   - C++11: 规定局部静态变量初始化线程安全。编译器通过guard变量（如__cxa_guard_acquire和__cxa_guard_release）加锁确保只初始化一次，其他线程遇到初始化会挂起等待。

面试官: C++中局部静态变量的问题？

回答:
1. 特点: 存储在静态存储区，自动初始化为0，作用域局部但生命周期到程序结束。
2. 构造和析构: 
   - 首次执行到定义处时构造，析构顺序与构造顺序相反。
   - 问题: 构造顺序取决于实际执行路径（可能不可预知），且分散的局部静态变量易忽略相互依赖关系，可能导致问题。
3. 建议: 尽量少使用静态变量，避免潜在问题。
4. 函数返回局部静态变量: 允许（如示例代码），但需注意其持久性可能带来意外状态保留。

示例代码片段:
int tmp() {
    static int b = 5;  // 局部静态变量
    return b;
}
// 可返回，且值在多次调用间保持

面试官: const与指针的区别？

回答:
主要两种形式:
1. 指向常量的指针: 
   - 写法: const int *p 或 int const *p
   - 含义: 不能通过解引用(*p)修改所指内容，但指针本身可指向其他地址。
2. 常量指针:
   - 写法: int *const p
   - 含义: 指针本身地址不可变（初始化后不能指向其他地址），但可通过解引用(*p)修改所指内容。
注意: const int p 是常量本身（非指针），初始化后值不可变。
