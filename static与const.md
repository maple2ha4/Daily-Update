_1)面试官: static和const分别怎么用？

回答:
static的用法:
1. 对于变量:
   - 局部变量: 在局部变量前加static使其成为局部静态变量。存储在data段，只能初始化一次，作用域仍为局部，但生命周期延长至程序结束。
   - 全局变量: 在全局变量前加static使其成为全局静态变量。存储在静态存储区，自动初始化为0，作用域仅限于定义它的文件内。

2. 对于函数:
   - 修饰普通函数，限制函数作用域仅在定义它的文件内，防止多人开发时的命名冲突。

3. 对于类:
   - 成员变量: 用static修饰使该成员成为类的全局变量，被所有对象共享。必须在类外初始化（const static成员可在类内初始化）。
   - 成员函数: 用static修饰使该函数属于类而非对象，所有对象共享，不含this指针，可独立访问（无需创建对象实例）。

const的用法:
1. 修饰变量: 限定变量为不可修改。
2. 修饰指针:
   - 指向常量的指针（const int *p 或 int const *p）: 不能通过解引用修改所指内容。
   - 常量指针（int *const p）: 指针本身地址不可变，但可通过解引用修改所指内容。
3. 和函数结合:
   - const int& fun(int& a);  //修饰返回值
   - int& fun(const int& a);  //修饰形参
   - int& fun(int& a) const;  //const成员函数，不能修改成员变量
4. 和类结合:
   - const修饰成员变量: 在对象生命周期内为常量，但不同对象可不同值。只能在初始化列表初始化。
   - const修饰成员函数: 防止函数修改成员变量值。
   - const对象: 常对象，只能调用常成员函数。


_2)面试官: 类里面static和const可以同时修饰成员函数吗？

回答: 不可以。原因如下:
- static成员函数属于类而非对象，没有this指针。
- const成员函数需要隐式的const this*参数来确保不修改对象状态。
- 两者语义矛盾：static表示函数仅作用于类的静态变量，与实例无关；const表示函数不修改实例状态，与静态变量无关。
- 因此，C++中不允许同时用static和const修饰成员函数。


_3)面试官: static初始化时机和线程安全问题？

回答:
面试官您好，关于static变量的初始化时机和线程安全问题，我的理解如下：
初始化时机
C语言：
所有静态变量（包括全局变量和函数内的静态局部变量）在程序main函数执行之前完成内存分配和初始化。
其初始值若在编译期已知（如static int i = 5;），则直接写入程序的数据段，由加载器在程序启动时完成初始化。
C++语言：
静态初始化/编译期初始化：在程序加载时完成，包括：
- 零初始化：未显式初始化的静态变量被设为0值。
- 常量初始化：编译期值已知的变量（如constexpr、字面量初始化）。
动态初始化/运行时初始化：需要执行代码的初始化（如调用构造函数、函数返回值初始化）。
- 非局部静态变量（全局、命名空间、类静态成员变量）：在main函数开始之前进行，但不同编译单元间的初始化顺序不确定。
- 局部静态变量：在控制流首次经过其声明语句时进行（惰性初始化）。

线程安全
C语言：
初始化安全：所有初始化在main之前完成，处于单线程环境，因此是线程安全的。
访问安全：初始化完成后，多线程下的读写操作需要程序员自行加锁保证安全。
C++语言：
非局部静态变量：
- 初始化安全：在main之前初始化，处于单线程环境，因此是安全的。
- 访问安全：初始化后的并发读写需程序员负责同步。
局部静态变量 (C++11起)：
- 初始化安全：是线程安全的。C++11标准强制要求编译器必须保证其初始化操作只执行一次。编译器会使用类似双重检查锁定的机制，确保即使多线程同时触发初始化，也只有一个线程执行构造，其他线程会阻塞等待完成。
- 访问安全：初始化完成后，其作为一个共享变量，多线程下的读写操作仍需程序员自己保证线程安全。

总结：C++11保证了局部静态变量初始化过程的线程安全，这是实现线程安全单例模式的基础。但所有静态变量初始化后的使用过程，其线程安全都必须由开发者通过锁等同步机制来保障。

_4)面试官: C++中局部静态变量的问题？

回答:
1. 特点: 存储在静态存储区，自动初始化为0，作用域局部但生命周期到程序结束。
2. 构造和析构: 
   - 首次执行到定义处时构造，析构顺序与构造顺序相反。
   - 问题: 构造顺序取决于实际执行路径（可能不可预知），且分散的局部静态变量易忽略相互依赖关系，可能导致问题。
3. 建议: 尽量少使用静态变量，避免潜在问题。
4. 函数返回局部静态变量: 允许（如示例代码），但需注意其持久性可能带来意外状态保留。

示例代码片段:
int tmp() {
    static int b = 5;  // 局部静态变量
    return b;
}
// 可返回，且值在多次调用间保持

_5)面试官: const与指针的区别？

回答:
主要两种形式:
1. 指向常量的指针: 
   - 写法: const int *p 或 int const *p
   - 含义: 不能通过解引用(*p)修改所指内容，但指针本身可指向其他地址。
2. 常量指针:
   - 写法: int *const p
   - 含义: 指针本身地址不可变（初始化后不能指向其他地址），但可通过解引用(*p)修改所指内容。
注意: const int p 是常量本身（非指针），初始化后值不可变。
