面试官：请解释移动构造函数的工作原理和意义

应聘者：
好的，我将从问题根源、解决方案和实际应用三个方面来解释移动构造函数。

一、问题根源：浅拷贝与指针悬挂
假设我们有一个管理堆内存的类：

class MyClass {
public:
    int* m_val; // 指向堆内存的指针
};

默认拷贝构造函数进行浅拷贝，只复制指针地址：

MyClass obj1;
obj1.m_val = new int(100);

MyClass obj2 = obj1; // 浅拷贝：两个对象指向同一内存

// 析构时：obj2先delete内存，obj1再delete同一内存 → 未定义行为（程序崩溃）

深拷贝构造函数解决正确性问题但带来性能开销：

MyClass(const MyClass& other) {
    m_val = new int;      // 分配新内存
    *m_val = *other.m_val; // 复制数据内容
}

二、解决方案：移动构造函数
您提供的代码正是移动构造函数的典型实现：

MyClass(MyClass&& a) noexcept { // 参数为右值引用
    m_val = a.m_val;   // 第一步：浅拷贝，直接接管资源
    a.m_val = nullptr; // 第二步：将源对象指针置空
}

这个方案同时解决两个问题：

1. 解决正确性问题：
   • 将a.m_val置为nullptr
   • 源对象析构时delete nullptr是安全操作
   • 新对象独享资源所有权，确保只释放一次

2. 解决性能问题：
   • 无新内存分配（无new操作）
   • 无数据复制（无*m_val = *other.m_val）
   • 只有两次指针赋值，开销极低

三、触发时机和实际应用
移动构造函数在以下情况被调用：

1. 初始化时源对象是右值（临时对象）：
MyClass a = createObject(); // 编译器优先选择移动构造

2. 使用std::move显式转换：
MyClass a;
MyClass b = std::move(a); // 显式移动资源

四、完美类比
• 深拷贝（拷贝构造）：买新房并复制所有家具（耗时耗力）
• 移动构造：直接拿到旧房钥匙，换掉门牌号（高效零浪费）

总结：
移动构造函数通过"浅拷贝+置空"的方式，既解决了浅拷贝的指针悬挂问题，又避免了深拷贝的性能开销，实现了高效的资源所有权转移，是现代C++提升性能的关键机制。
