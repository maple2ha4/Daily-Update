面试官: 说一下你的上传功能

回答:
  1.客户端： 
    首先用户点击选择要上传的文件，点击上传文件按钮，客户端就会获取[文件路径、文件大小]、计算文件的MD5值（用于秒传验证），
    接着客户端构造上传请求协议包(协议包内含 [用户id、文件名称、文件大小、文件MD5值])。
    然后发送上传请求到服务器，并在客户端本地记录文件上传信息[文件路径、大小、文件id]（用于后续管理）。我这里用的是map，将文件名映射成文件信息。

  2.服务器：
    服务器网络模块接收到请求包，交由kernel模块解析处理。kernel模块解析到这是一个上传请求协议包，调用上传文件回复包函数。
    首先解析客户端上传请求数据包，并准备响应包。接着通过MD5值查询数据库检查文件是否存在。
    存在，则提取数据库查询结果（原始上传用户、文件id、文件引用计数），并设置响应包中的文件id。
    接着判断这个文件是不是自己上传的。如果是自己上传的，则检查map表里是否有这个文件未完整的上传记录（因为文件完全写入后会从map中删除记录）。
    如果没有这个文件未完整上传的记录，表示文件已完整上传过；如果有记录，则将响应包结果设置为断点续传，并设置回复包已上传的位置。
    如果不是自己上传的，则启用秒传，更新文件引用计数，建立新用户与文件的关联。
    如果数据库不存在该文件，则需完整上传。将响应包结果设置为普通上传，并构建文件存储路径，将文件信息插入数据库，并获取数据库中为该文件分配的id，建立用户与文件的关联。
    接着创建空文件准备接收数据，并记录上传状态信息，最后发送响应给客户端。

  3.客户端：
    客户端接收到响应包，解析到这是上传文件响应包，则发送一个信号，关联该信号的上传文件函数响应。
    首先获取文件名并查找本地存储的上传信息（在断点续传或正常传时创建文件上传任务时作为上传文件信息指针参数），
    并根据服务器返回的结果类型进行不同处理。若响应包结果为文件已上传过，则提示文件已上传过；若结果为秒传，则提示秒传成功（引用计数和数据库关联在服务器端已完成更新）；
    若结果为断点续传或正常传，则创建文件上传任务并加入线程池。文件上传任务类包含[上传文件信息、服务器分配的文件id、文件上传的起始位置、父对象指针（用于回调）]，并将任务加入到线程池队列。
    工作线程执行任务，先打开本地文件，然后处理断点续传逻辑，将文件指针定位到上次中断的位置。接着准备文件块传输协议包，从文件循环读取并发送文件块。
    我这个项目设置的是每次最多读取ONE_PAGE4096字节，也就是一次4KB。直至读取完成。传输完成后从上传管理map中溢出已完成的任务。

    注释：这一步是客户端读取要传输的文件内容，写入是在下一步服务器收到文件块传输请求包后调用uploadfileblockrq进行写入的。

  4.服务器：
    服务器接受到文件块传输请求包，调用处理客户端上传文件数据块请求函数。
    首先解析数据包，获取对应的上传文件信息（从map中查询是否有对应的文件信息），从而检查上传是否有效。
    接着将数据块写入到对应的文件中，每次更新已上传的位置，当上传完成（上传位置等于文件大小时），关闭文件，从map中清楚上传记录并释放资源。





# 面试官：你的网盘项目是怎么保证传输文件的完整性的？
回答：
 1. 客户端（传输前准备）：  
    首先在文件上传发起阶段，客户端会做**全文件唯一标识校验**。用户选择文件后，客户端通过`FileDigest`函数（对应`Widget.cpp`实现）对文件进行全量扫描——每次读取1024字节缓冲区，逐块计算MD5值，
    最终生成整个文件的唯一MD5哈希（比如"a1b2c3..."）。这个MD5会和文件名、文件大小一起，封装进`STRU_UPLOADFILEINFO_RQ`协议包（协议定义在`Packdef.h`），作为文件的“数字指纹”发送给服务器。这一步的核心是：**提前给文件生成唯一标识，为后续完整性校验提供基准**。  

    同时，客户端会初始化**上传状态跟踪机制**。在本地`m_mapFileNametoFileInfo`（`Widget.cpp`中的map结构）中记录文件信息，包括：文件路径、总大小、当前待传位置（初始为0）、已传输块的校验记录（扩展逻辑：每个4096字节块对应一个临时MD5，存储在map的value中）。这一步是为了后续分块传输时，能快速定位已传和未传内容，避免重复传输或漏传。  


 2. 服务器（接收请求阶段）：  
    服务器收到客户端的上传请求包后，首先进行**基准信息存储与校验准备**。在`TCPKernel.cpp`的上传请求处理函数中，服务器会解析出文件MD5、大小等信息，先在MySQL的`file`表中查询该MD5是否存在（用于秒传判断），同时将MD5与分配的`m_fileId`（文件唯一ID）绑定，存入内存中的`m_mapFileIdtoFileInfo`（上传状态map）。  

    接着，服务器会初始化**文件接收上下文**：创建空文件（路径基于`file`表的`f_path`字段），在`UploadFileInfo`结构体中记录“预期总大小”“当前已接收位置”“文件MD5基准值”，并设置“块校验阈值”——要求客户端后续传输的每个块必须携带“块序号”和“块长度”（扩展逻辑：基于项目中分块传输的`ONE_PAGE=4096`字节设计，块序号=当前位置/4096，确保顺序性）。  


 3. 客户端（分块传输阶段）：  
    客户端收到服务器的“允许上传”响应后，通过线程池（`Widget.cpp`的`Threadpool`）启动分块传输，每个块的传输都包含**三重校验逻辑**：  
    - 第一重：**块顺序校验**。客户端根据`STRU_UPLOADFILEINFO_RS`返回的`m_pos`（已传位置），计算当前应传块的序号（比如`m_pos=4096`则序号为1），并在`STRU_UPLOADFILEBLOCK_RQ`包中携带该序号（扩展项目中`m_fileNum`字段的含义，使其同时表示块序号），确保服务器按顺序接收。  
    - 第二重：**块长度校验**。每次读取`ONE_PAGE=4096`字节（最后一块可能不足），读取后立即检查实际长度是否与预期一致（比如非最后一块必须是4096字节），不一致则重新读取，避免因本地文件损坏导致的块内容不完整。  
    - 第三重：**确认重传机制**。客户端发送块后，会等待服务器的“块接收确认”（扩展项目中隐性逻辑：服务器接收并写入成功后，会通过响应包返回当前已接收位置）。如果5秒内未收到确认，或收到的已接收位置与预期不符（比如发送块1后，服务器返回位置仍为0），则判定块丢失，从`m_pos`重新读取并发送该块。  


 4. 服务器（分块接收与写入阶段）：  
    服务器在`TCPKernel.cpp`的`uploadfileblockrq`函数中处理每个文件块，通过**四重校验确保写入完整性**：  
    - 第一重：**块合法性校验**。根据`m_fileId`在`m_mapFileIdtoFileInfo`中查询文件信息，检查块序号是否与当前已接收位置匹配（比如当前位置=4096，块序号必须为1），不匹配则拒绝写入，通知客户端重新发送对应块。  
    - 第二重：**内容完整性校验**。计算接收块的临时MD5（扩展逻辑：与客户端块MD5比对），若不一致则判定内容损坏，要求客户端重传。  
    - 第三重：**写入原子性校验**。调用`fwrite`写入块数据后，立即通过`fflush`强制刷新到磁盘，再调用`ftell`获取当前文件指针位置，确认写入长度与块长度一致（比如写入4096字节后，位置应增加4096）。若不一致，说明磁盘写入失败，删除该块数据并要求重传。  
    - 第四重：**进度一致性校验**。每次写入后更新`UploadFileInfo`的`m_pos`，并对比`m_pos`与文件总大小。若`m_pos`超过总大小，判定为异常（可能是客户端恶意发送），立即终止上传并删除文件。  


 5. 客户端（传输完成校验）：  
    当客户端发送完所有块（本地`m_pos`等于文件总大小），会主动向服务器发送“传输完成确认包”（扩展项目逻辑），并等待服务器的最终校验结果。若服务器返回“文件完整”，客户端会：  
    - 从`m_mapFileNametoFileInfo`中删除该文件记录（表示上传完成）；  
    - 弹窗提示“上传成功”，并在日志中记录“文件MD5：xxx，传输完整”（通过`LOG_INFO`）。  


 6. 服务器（最终完整性校验）：  
    当服务器检测到`m_pos`等于文件总大小（所有块传输完成），会执行**最终完整性校验**：  
    - 调用与客户端一致的`MD5`算法，重新计算服务器本地存储文件的全量MD5；  
    - 将计算结果与客户端上传请求时提供的原始MD5比对：  
      - 若一致：更新MySQL`file`表的文件状态为“已完成”，删除`m_mapFileIdtoFileInfo`中的临时记录，向客户端返回“传输完整”响应；  
      - 若不一致：删除服务器端不完整文件，在日志中记录“MD5不匹配，文件损坏”（通过`LOG_ERROR`），并通知客户端“传输失败，请重新上传”。  


通过以上六层校验——从传输前的MD5基准建立，到分块传输中的顺序、长度、内容校验，再到传输完成后的全量MD5比对，确保了文件从客户端到服务器的传输完整性，哪怕中间出现网络波动、磁盘写入失败等问题，也能通过重传和校验机制修复，最终存储在服务器的文件一定是完整的。












a.客户端
void Widget::on_pushButton_clicked()//上传文件
{
    //获取上传文件信息（文件名，大小，MD5）
    // 1. 获取用户选择的文件路径
    QString filePath = QFileDialog::getOpenFileName(this,tr("Open file"),
                                                  ".",//打开文件的根目录
                                                    "ALL files (*.*);;Images (*.png *.xpm *.jpg);;Text files(*.txt))");
    // 检查用户是否取消了文件选择
    if(filePath.isEmpty())
    {
        return; // 用户取消选择，直接返回
    }
    
    // 2. 从完整路径中提取文件名（最后一部分）
    QString fileName =filePath.section('/',-1);
    QFile file(filePath);
    
    // 3. 获取文件大小
    long long filesize;
    if(file.open(QIODevice::ReadOnly))  // 以只读方式打开文件
    {
        filesize=file.size();   // 获取文件大小（字节数）
        file.close();   // 立即关闭文件
    }
    else
    {
        printf("file open fail!");
    }
    
    // 4. 计算文件的MD5校验值（用于秒传验证）
    string strMD5 = FileDigest(filePath);   //记录md5值
    //qDebug()<<strMD5.c_str();
    //上传文件信息请求表
    
    // 5. 构造上传请求协议包
    STRU_UPLOADFILEINFO_RQ sur;
    sur.m_filesize = filesize;
    sur.m_userid = m_userId;
    strcpy(sur.m_szFileMD5, strMD5.c_str());
    strcpy(sur.m_szFileName, fileName.toStdString().c_str());
    
    // 6. 发送上传请求到服务器
    m_pKernel->sendData((char*)&sur,sizeof(sur));
    
    // 7. 在客户端本地记录文件上传信息 文件路径 大小 文件id （用于后续管理）
    UploadFileInfo* p = new UploadFileInfo;
    strcpy(p->m_szFilePath,filePath.toStdString().c_str());
    p->m_fileId = 0;    // 初始文件ID（服务器会分配真实ID）
    p->m_fileSize=filesize;
    m_mapFileNametoFileInfo[fileName] = p;    // 将上传信息存入映射表（文件名->上传信息）

}
    此时只是发送了上传请求，真正的文件传输会在：收到服务器响应后（slot_uploadfileinfo）根据响应类型（正常传/秒传/续传）执行不同操作
    这个函数是文件上传流程的起点，负责收集文件信息并初始化上传任务，后续的实际传输由其他函数处理。



------------------------------------------------------------------------------------------------------------------------------------------------------------------


b.服务器
void TCPKernel::uploadfileinforq(SOCKET sock, char *szbuf)
{
    // 1. 解析客户端上传请求数据包
    STRU_UPLOADFILEINFO_RQ *psur=(STRU_UPLOADFILEINFO_RQ*)szbuf;
    char szsql[SQLLEN]={0};
    list<string> lststr;
    
    // 2. 准备响应包
    STRU_UPLOADFILEINFO_RS sur;
    strcpy(sur.m_szFileName,psur->m_szFileName);    // 拷贝文件名用于响应
    sur.m_pos = 0;    // 初始上传位置为0
    
    // 3. 查询数据库检查文件是否已存在（通过MD5值）
    sprintf(szsql,"select u_id, f_id, f_count from myview where f_md5 = '%s';", psur->m_szFileMD5);
    m_pSQL->SelectMySql(szsql,3,lststr);
    
    // 4. 判断数据库是否存在该文件
    if(lststr.size()>0)
    {
        // 4.1 存在，提取数据库查询结果
        string strUserId=lststr.front();    // 原始上传用户ID
        lststr.pop_front();
        string strFileId=lststr.front();    // 文件ID
        lststr.pop_front();
        string strFilecount=lststr.front(); // 文件引用计数
        lststr.pop_front();
        
        long long userId = atoll(strUserId.c_str());
        long long FileId = atoll(strFileId.c_str());
        sur.m_fileId = FileId;    // 设置响应包中的文件ID
        
        //判断这个文件是不是自己传的，1如果没有传完--断点续传 2如果传完了--重复上传
        // 4.2 判断是否是同一用户上传
        if(psur->m_userid == userId)
        {
            // 同一用户上传同一文件
            sur.m_szResult = _uploadinfo_isuploaded;  // 默认标记为已上传
            
            // 检查是否有未完成的上传记录
            UploadFileInfo*pInfo = m_mapFileIdtoFileInfo[FileId];

            //pInfo不为空代表有上传记录但未完全上传或未上传过(这里指前者) 在TCPKernel::uploadfileblockrq文件完全上传后会从map中删除记录
            if(pInfo)
            {
                // 存在未完成的上传记录，启用断点续传
                sur.m_szResult=_uploadinfo_continue; 
                printf("continue_transfer\n");
                sur.m_pos = pInfo->m_pos;   // 返回已上传的位置
            }
            else    //pInfo为空 文件已完整上传过
            {
                printf("istransfered!\n");
            }

        }
        else
        {
            // 不同用户上传相同文件，启用秒传
            sur.m_szResult = _uploadinfo_speedtranfer;
            
            // 4.3 更新文件引用计数
            sprintf(szsql,"update file set f_count = f_count + 1 where f_id = %lld;", FileId);
            m_pSQL->UpdateMySql(szsql);
            
            // 4.4 建立新用户与文件的关联
            sprintf(szsql,"insert into user_file(u_id, f_id) values(%lld, %lld);", psur->m_userid, FileId); //关联用户与文件
            m_pSQL->UpdateMySql(szsql);
            
            printf("others transfered!count+1\n");
        }
    }
    else
    {
        // 5. 数据库不存在该文件，需要完整上传
        printf("normal transfer!\n");
        sur.m_szResult=_uploadinfo_normal;
        
        // 5.1 构造文件存储路径
        char szFilePath[MAX_PATH]={0};
        //C:\mydisk/+ userid/+ filename
        QString fileName = QString::fromUtf8(psur->m_szFileName);
        sprintf(szFilePath,"%s%lld/%s",m_szSystemPath,psur->m_userid,fileName.toStdString().c_str());

        // 5.2 将文件信息插入数据库
        sprintf(szsql,"insert into file(f_name,f_size,f_path,f_md5) values('%s',%lld,'%s','%s')",
                psur->m_szFileName,psur->m_filesize,szFilePath,psur->m_szFileMD5);
        m_pSQL->UpdateMySql(szsql);

        // 5.3 获取新插入的文件ID
        sprintf(szsql,"select f_id from file where f_md5 = '%s'", psur->m_szFileMD5); //通过md5找到文件id
        m_pSQL->SelectMySql(szsql,1,lststr);
        if(lststr.size()>0)
        {
            string strFileId = lststr.front();
            lststr.pop_front();
            
            // 5.4 建立用户与文件的关联
            sprintf(szsql,"insert into user_file(u_id, f_id) values(%lld,%lld);",psur->m_userid,atoll(strFileId.c_str()));
            sur.m_fileId=atoll(strFileId.c_str());
            m_pSQL->UpdateMySql(szsql);
        }
        
        //FILE* pfile=fopen(szFilePath,"wb");
        //记录文件信息 fileid--(文件指针 大小 位置)
        
        // 5.5 在服务器创建空文件准备接收数据
        QString fullPath = szFilePath;
        std::wstring wpath = fullPath.toStdWString();
        FILE* pfile = _wfopen(wpath.c_str(), L"wb");    // 二进制写模式打开文件
        if(!pfile)
        {
            printf("create file fail\n");
        }
        
        // 5.6 记录上传状态信息
        UploadFileInfo* p = new UploadFileInfo;
        p->m_pfile = pfile;   // 文件指针
        p->m_fileSize=psur->m_filesize;  // 文件总大小
        p->m_pos = 0;   // 当前上传位置
        p->m_userId = psur->m_userid;   // 用户ID
        m_mapFileIdtoFileInfo[sur.m_fileId] = p;    // 存入上传状态Map
    }
    // 6. 发送响应给客户端
    m_pTCPNet->sendData(sock,(char*)&sur,sizeof(sur));
}
这个函数是服务器处理文件上传的核心逻辑，实现了网盘系统的关键功能：秒传、断点续传和正常上传。通过MD5校验和状态管理，显著提升了文件上传的效率和可靠性。



------------------------------------------------------------------------------------------------------------------------------------------------------------------



c.客户端
void TCPKernel::dealData(const char *szbuf)
{
    //todo
    switch(*szbuf)
    {
    case _default_protocol_uploadfileinfo_rs:
        emit signal_uploadfileinfo((STRU_UPLOADFILEINFO_RS*)szbuf);
        break;
}

void Widget::slot_uploadfileinfo(STRU_UPLOADFILEINFO_RS *psur)
{
    // 1. 获取文件名并查找本地存储的上传信息
    QString strFileName = psur->m_szFileName;
    UploadFileInfo* pInfo = m_mapFileNametoFileInfo[strFileName];

    // 2. 根据服务器返回的结果类型进行不同处理
    if(psur->m_szResult == _uploadinfo_isuploaded)
    {
        //QMessageBox弹出一个模态对话框，告知用户某个操作已完成
                           //  父类指针  窗口标题       对话框正文
        // 2.1 文件已上传过（重复上传）
        QMessageBox::information(this,"uploadfile","file is uploaded");
    }
    else if(_uploadinfo_speedtranfer == psur->m_szResult)
    {
        // 2.2 秒传成功（文件已存在于服务器）
        qDebug() << "speedtransfer\n";
    }
    else if(psur->m_szResult == _uploadinfo_continue || psur->m_szResult == _uploadinfo_normal)
    {
        // 2.3 需要实际传输文件（正常上传或断点续传）
        // 创建文件上传任务并加入线程池
        task *p = new SendFileItask(
            pInfo,  //上传文件信息
            psur->m_pos,    //起始位置（续传时为断点位置）
            psur->m_fileId, //服务器分配的文件id
            this);  //父对象指针，用于回调
        m_tp.push(p);   //将任务加入到线程池队列
    }

    //将文件信息显示到控件上
    // 3. 更新UI显示
    // 3.1 在表格中插入新行显示文件信息
    QTableWidgetItem* p = new QTableWidgetItem(QIcon("./pic.JPG"),strFileName);
    ui->tableWidget->setItem(m_FileNum, 0, p);  // 第一列：文件名（带图标）

    // 3.2 显示文件大小
    QString strFileSize = QString::number(pInfo->m_fileSize);
    p = new QTableWidgetItem(strFileSize);
    ui->tableWidget->setItem(m_FileNum,1,p);    // 第二列：文件大小

    // 3.3 显示当前时间（作为上传时间）
    QDateTime datetime = QDateTime::currentDateTime();
    QString strDateTime = datetime.toString("dd.MM.yyyy HH.mm.ss");
    p = new QTableWidgetItem(strDateTime);  // 第三列：上传时间
    ui->tableWidget->setItem(m_FileNum,2,p);

    ++m_FileNum;    // 增加文件计数，为下一个文件准备
    // 4. 显示上传成功提示
    QMessageBox::information(this,"uploadfile","file upload success");
}

经过线程池push->run后

void SendFileItask::run()
{
    // 转换UTF-8路径为宽字符
    // 使用_wfopen打开文件
    // 1. 打开本地文件
    FILE* pfile = _wfopen(utf8ToWide(m_pInfo->m_szFilePath).c_str(), L"rb");
    if (!pfile) {
        qDebug() << "Failed to open file:" << m_pInfo->m_szFilePath;
        return; // 直接返回或处理错误
    }

    // 2. 处理断点续传逻辑
    if(m_pos)
    {
        //如果是断点续传
        // 将文件指针定位到上次中断的位置
        fseek(pfile,m_pos,SEEK_SET);
    }
    //正常发送文件内容

    // 3. 准备文件块传输协议包
    STRU_UPLOADFILEBLOCK_RQ sur;
    sur.m_fileId = m_fileId;    //设置服务器分配的文件ID

    // 4. 循环读取并发送文件块
    while(1)
    {
        // 4.1 从文件读取数据块（每次最多读取ONE_PAGE大小）
        ssize_t nReadNum = fread(
            sur.m_szFileContent,    // 数据缓冲区
            sizeof(char),           // 每个元素大小
            sizeof(sur.m_szFileContent),    // 缓冲区容量（协议包定义为ONE_PAGE=4096）
            pfile);                 // 文件指针
        
        // 4.2 成功读取到数据
        if(nReadNum > 0)
        {
            //qDebug()<<"nReadNum="<<nReadNum<<endl;
            sur.m_fileNum=nReadNum; // 设置实际读取的字节数
            // 通过内核对象发送数据块到服务器
            m_pWidget->m_pKernel->sendData((char*)&sur,sizeof(sur));
        }
        else
        {
            // 读取结束或出错（nReadNum=0）
            //qDebug()<<"break:nReadNum="<<nReadNum<<endl;
            break;
        }
    }
    
    // 5. 资源清理
    fclose(pfile);// 关闭文件
    
    // 6. 从上传管理Map中移除已完成的任务
    QString strFilePath = m_pInfo->m_szFilePath;
    strFilePath = strFilePath.section('/',-1);  // 提取纯文件名
    auto ite = m_pWidget->m_mapFileNametoFileInfo.begin();
    while(ite != m_pWidget->m_mapFileNametoFileInfo.end())
    {
        if(ite->first == strFilePath)
        {
            ite = m_pWidget->m_mapFileNametoFileInfo.erase(ite);
            break;
        }
        ite++;
    }
}



------------------------------------------------------------------------------------------------------------------------------------------------------------------



d.服务器
// 处理客户端上传文件数据块的请求
void TCPKernel::uploadfileblockrq(SOCKET sock, char *szbuf)
{
    //将文件内容写入到 对应文件
    // 1. 解析数据包
    STRU_UPLOADFILEBLOCK_RQ *psur = (STRU_UPLOADFILEBLOCK_RQ*)szbuf;
    
    // 2. 获取对应的上传文件信息
    UploadFileInfo *p = m_mapFileIdtoFileInfo[psur->m_fileId];
    //客户端与服务器各有一个map 任务线程删除的是客户端完成文件传输后的map中的记录
    //这里服务端的map在TCPKernel::uploadfileinforq()时会将上传状态传入服务器map
    
    // 3. 校验上传记录有效性
    if(!p)
    {
        std::cout<<"TCPKernel::uploadfileblockrq的 UploadFileInfo 为空"<<endl;
        return; // 不存在对应的上传记录，直接返回
    }
    //将文件信息写入到对应的文件中
    //printf("m_pos:%d  filesize:%d\n",p->m_pos,p->m_fileSize);
    
    // 4. 将数据块写入文件
    ssize_t nWritNum = fwrite(psur->m_szFileContent,    // 数据块指针
                              sizeof(char),             // 每个元素大小（1字节）
                              psur->m_fileNum,          // 数据块实际长度（可能小于ONE_PAGE）
                              p->m_pfile);              // 目标文件指针
    
    // 5. 处理写入结果
    if(nWritNum > 0)
    {
        // 5.1 更新已上传位置
        p->m_pos += nWritNum;
        // 5.2 检查是否上传完成
        if(p->m_pos == p->m_fileSize)
        {
            // 6. 文件传输完成处理
            fclose(p->m_pfile); // 关闭文件
            
            // 6.1 清理上传记录
            auto ite = m_mapFileIdtoFileInfo.begin();
            while(ite != m_mapFileIdtoFileInfo.end())
            {
                if(ite->first == psur->m_fileId)
                {
                    // 6.2 释放资源
                    auto p = ite->second;
                    delete p;   // 释放UploadFileInfo对象
                    p = nullptr;    // 避免野指针
                    
                    // 6.3 从Map中移除记录
                    m_mapFileIdtoFileInfo.erase(ite); //文件上传完成 从map中删除文件记录
                    break;
                }
                ite++;
            }
        }
    }
}

1.STRU_UPLOADFILEBLOCK_RQ结构包含：
  •m_fileId：服务器分配的文件唯一标识
  •m_szFileContent：文件数据块内容
  •m_fileNum：实际数据长度

2.​上传记录校验​​
  •通过m_mapFileIdtoFileInfo查找对应上传记录
  •不存在记录时立即返回，避免空指针异常

3.​​文件写入操作​​
  •fwrite将数据块追加写入文件
  •psur->m_fileNum可能小于ONE_PAGE（最后一块数据）

4.​​进度更新​​
  •p->m_pos累计记录已上传字节数
  •严格校验p->m_pos == p->m_fileSize判断完成

5.资源清理​​
  •完成时三步操作：
    关闭文件句柄（避免资源泄漏）
    删除堆内存对象
    移除Map中的记录
