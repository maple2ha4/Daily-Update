-前置知识:string字面值是左值 因为在C++中string可以看作char数组
与其他字面值的对比：
• int型字面值：42（纯右值，不能取地址）
• double型字面值：3.14（纯右值，不能取地址）  
• char型字面值：'a'（纯右值，不能取地址）
• 字符串字面值："hello"（左值，可以取地址）
在C++11中引入了右值引用，因为右值的生命周期很短，右值引用的引入，使得可以延长右值的生命周期。
在C++中规定，右值引用是&&即由2个&表示，而左值引用是一个&表示。右值引用的作用是为了绑定右值。


_1)面试官：右值引用变量本身是左值还是右值？

回答：
这个问题确实是C++移动语义中最关键的概念之一。我的答案是：右值引用变量本身是一个左值。

核心规则：
• 如果一个表达式有名字，那么它就是左值
• std::move(x)或函数返回右值引用的表达式没有名字，所以是xvalue（将亡值，属于右值）
• 但是，一旦创建变量来接收它，这个变量本身有名字，就变成了左值

举例说明四种情况：
1. 传递匿名临时对象：foo(std::string("hello"))中的"hello"是右值
2. 传递函数返回值：foo(get_string())中的get_string()返回临时对象，是右值
3. 使用std::move：std::move(str)这个表达式的结果是右值
4. 创建右值引用变量：std::string&& rref = ... 中的rref有名字，所以是左值

这一点为什么至关重要：
因为在函数内部处理参数时，需要特别注意：
void take_string(std::string&& s) {
    // s是有名字的形参，所以在这里是左值！
    // another_function(s); // 错误！不能将左值传递给需要右值引用的函数
    another_function(std::move(s)); // 正确！需要再次使用std::move转换
}

背后的逻辑：
• std::move的本质：只是强制类型转换static_cast<T&&>(x)，告诉编译器可当作右值处理
• 移动的发生时机：真正移动发生在构造或赋值时，当用右值构造新对象时会选择移动构造函数

常见错误案例：
std::string&& rref = std::move(my_string); // 正确：rref绑定到右值
std::string s1 = rref; // 错误！发生拷贝构造，因为rref是左值
std::string s2 = std::move(rref); // 正确！发生移动构造，因为std::move(rref)是右值

总结表格：
表达式                 类别        原因
std::string("hello")  纯右值     匿名临时对象
get_string()          纯右值     返回临时对象的函数调用
std::move(x)          将亡值     强制转换为右值的表达式
std::string&& rref    左值       有名字的变量
void foo(T&& s)中的s  左值       有名字的形参变量

黄金法则：
右值引用是用来绑定右值的，但右值引用类型的变量本身是左值。

理解这一点，就能彻底明白为什么在函数内部处理参数时，经常需要再次使用std::move。

详细了解右值引用:https://www.cnblogs.com/qicosmos/p/4283455.html
