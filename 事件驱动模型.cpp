比较重要的需要知道的一点：
IO 操作的具体执行（即内核层的实际数据传输过程，如磁盘数据读取至内核缓冲区、网卡数据接收至内核缓冲区）由操作系统内核完成，而非应用层线程；因此在 IO 密集型场景下选择 IO 多路复用模型，核心原因有两点：
避免线程大量闲置浪费：若采用传统多线程模型，为应对大量并发 IO 请求需创建大量应用线程，但这些线程在大部分时间内会因等待内核完成 IO 操作而处于阻塞闲置状态（仅等待不执行有效任务），既占用宝贵的内存资源（每个线程需独立栈空间），也无法将 CPU 用于处理有效业务逻辑；
规避高频线程切换开销：即使部分线程从阻塞转为就绪，操作系统也需频繁进行线程上下文切换（保存当前线程的寄存器、栈指针等状态，加载新线程的状态）—— 该过程会消耗 CPU 时钟周期，且 IO 密集型场景下线程阻塞 / 就绪的频率极高，导致线程切换开销在 CPU 总消耗中占比显著升高，进一步降低整体性能；
而 IO 多路复用可让少量应用线程（甚至单线程）通过轮询内核的 IO 就绪状态，高效管理大量并发 IO 请求：既无需创建大量线程，避免了线程闲置带来的资源浪费，也因线程数量极少，从根本上减少了线程上下文切换的频率与开销，最终实现更高的资源利用率与并发处理能力。

在事件驱动模型中，如果handler(event)直接处理 IO 操作，确实会导致阻塞，无法实现 "同时处理多个请求" 的效果。
这就需要引入一个重要机制：非阻塞 IO（Non-blocking I/O）与异步回调（Asynchronous Callback）。
关键解决方案在于：
  当需要执行 IO 操作时，不会直接在 handler 中等待结果
  而是发起一个异步 IO 请求，然后立即返回，让 Event Loop 可以继续处理其他事件
  当 IO 操作完成后，会产生一个新的事件（如 "IO 完成事件"）
  Event Loop 会捕获这个新事件，再调用对应的处理函数来处理 IO 结果  //重点 将完成产生的新事件再加入事件队列，然后再次处理

修正后的伪代码逻辑应该是这样：
while(true) {
    event = getEvent();  // 获取事件（不会阻塞）
    if (event是普通事件) {
        处理事件（快速完成，不包含阻塞操作）
    } else if (event是需要IO的事件) {
        发起异步IO请求（立即返回，不等待结果）
        注册IO完成后的回调函数
    } else if (event是IO完成事件) {
        调用之前注册的回调函数处理IO结果
    }
}

这就像餐厅服务员：
顾客点单（事件）→ 服务员记录订单后交给厨房（发起异步 IO）→ 立即去服务其他顾客（Event Loop 继续处理其他事件）
厨房做好菜（IO 完成）→ 服务员收到通知（IO 完成事件）→ 去上菜（执行回调）
这样即使在单线程中，也能 "同时" 处理多个需要 IO 操作的请求，因为大部分时间都在高效地等待和切换事件，而不是阻塞在 IO 操作上。
Node.js 就是基于这种模型实现的，这也是为什么它能在单线程下高效处理大量并发请求的原因。
